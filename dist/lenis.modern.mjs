import t from"tiny-emitter";import i from"virtual-scroll";function e(){return e=Object.assign?Object.assign.bind():function(t){for(var i=1;i<arguments.length;i++){var e=arguments[i];for(var s in e)Object.prototype.hasOwnProperty.call(e,s)&&(t[s]=e[s])}return t},e.apply(this,arguments)}const s=["duration","easing"];class r{to(t,i={}){let{duration:r=1,easing:o=(t=>t)}=i,n=function(t,i){if(null==t)return{};var e,s,r={},o=Object.keys(t);for(s=0;s<o.length;s++)i.indexOf(e=o[s])>=0||(r[e]=t[e]);return r}(i,s);this.target=t,this.fromKeys=e({},n),this.toKeys=e({},n),this.keys=Object.keys(e({},n)),this.keys.forEach(i=>{this.fromKeys[i]=t[i]}),this.duration=r,this.easing=o,this.currentTime=0,this.isRunning=!0}raf(t){if(!this.isRunning)return;this.currentTime=Math.min(this.currentTime+.001*t,this.duration);const i=this.easing(this.progress);this.keys.forEach(t=>{const e=this.fromKeys[t];this.target[t]=e+(this.toKeys[t]-e)*i}),1===i&&(this.isRunning=!1)}get progress(){return this.currentTime/this.duration}}class o extends t{constructor({duration:t=1.2,easing:e=(t=>1===t?1:1-Math.pow(2,-10*t)),smooth:s=!0,direction:o="vertical",wrapper:n=window,content:h=document.body}={}){var l,a,c;super(),this.onWindowResize=()=>{this.wrapperWidth=window.innerWidth,this.wrapperHeight=window.innerHeight},this.onWrapperResize=([t])=>{if(t){const i=t.contentRect;this.wrapperWidth=i.width,this.wrapperHeight=i.height}},this.onContentResize=([t])=>{if(t){const i=t.contentRect;this.contentWidth=i.width,this.contentHeight=i.height}},this.onVirtualScroll=({deltaY:t,originalEvent:i})=>{i.ctrlKey||(this.stopped?i.preventDefault():this.smooth&&4!==i.buttons&&(this.smooth&&i.preventDefault(),this.targetScroll-=t,this.targetScroll=Math.max(0,Math.min(this.targetScroll,this.limit)),this.scrollTo(this.targetScroll)))},this.onScroll=t=>{this.isScrolling&&this.smooth&&!this.holdWheelScrolling||(this.targetScroll=this.scroll=this.lastScroll=this.wrapperNode[this.scrollProperty],this.notify())},void 0!==arguments[0].lerp&&console.warn("Lenis: lerp option is deprecated, you must use duration and easing options instead. See documentation https://github.com/studio-freight/lenis"),window.lenisVersion="0.2.4",this.wrapperNode=n,this.contentNode=h,this.duration=t,this.easing=e,this.smooth=s,this.direction=o,this.wrapperNode.addEventListener("scroll",this.onScroll),this.wrapperNode===window?(this.wrapperNode.addEventListener("resize",this.onWindowResize),this.onWindowResize()):(this.wrapperHeight=this.wrapperNode.offsetHeight,this.wrapperWidth=this.wrapperNode.offsetWidth,this.wrapperObserver=new ResizeObserver(this.onWrapperResize),this.wrapperObserver.observe(this.wrapperNode)),this.contentHeight=this.contentNode.offsetHeight,this.contentWidth=this.contentNode.offsetWidth,this.contentObserver=new ResizeObserver(this.onContentResize),this.contentObserver.observe(this.contentNode),this.targetScroll=this.scroll=this.lastScroll=this.wrapperNode[this.scrollProperty],this.animate=new r;const p=(null==(l=navigator)||null==(a=l.userAgentData)?void 0:a.platform)||(null==(c=navigator)?void 0:c.platform)||"unknown";this.virtualScroll=new i({el:this.wrapperNode,firefoxMultiplier:50,mouseMultiplier:p.includes("Win")?1:.4,useKeyboard:!1,useTouch:!1,passive:!1}),this.virtualScroll.on(this.onVirtualScroll)}get scrollProperty(){let t;return t=this.wrapperNode===window?"horizontal"===this.direction?"scrollX":"scrollY":"horizontal"===this.direction?"scrollLeft":"scrollTop",t}start(){this.stopped=!1}stop(){this.stopped=!0}destroy(){var t;this.wrapperNode===window&&this.wrapperNode.removeEventListener("resize",this.onWindowResize),this.wrapperNode.removeEventListener("scroll",this.onScroll),this.virtualScroll.destroy(),null==(t=this.wrapperObserver)||t.disconnect(),this.contentObserver.disconnect()}get limit(){return"horizontal"===this.direction?this.contentWidth-this.wrapperWidth:this.contentHeight-this.wrapperHeight}raf(t){const i=t-(this.now||0);this.now=t,this.stopped||!this.smooth||this.holdWheelScrolling||(this.lastScroll=this.scroll,this.animate.raf(i),Math.round(this.scroll)===Math.round(this.targetScroll)&&(this.lastScroll=this.targetScroll),this.isScrolling&&(this.setScroll(this.scroll),this.notify()),this.isScrolling=this.scroll!==this.targetScroll)}get velocity(){return this.scroll-this.lastScroll}setScroll(t){"horizontal"===this.direction?this.wrapperNode.scrollTo(t,0):this.wrapperNode.scrollTo(0,t)}notify(){this.emit("scroll",{scroll:this.scroll,limit:this.limit,velocity:this.velocity,direction:this.direction,progress:this.scroll/this.limit})}scrollTo(t,{offset:i=0,immediate:e=!1,duration:s=this.duration,easing:r=this.easing}={}){let o;if("number"==typeof t)o=t;else if("top"===t||"#top"===t)o=0;else if("bottom"===t)o=this.limit;else{let i;if("string"==typeof t)i=document.querySelector(t);else{if(null==t||!t.nodeType)return;i=t}if(!t)return;let e=0;if(this.wrapperNode!==window){const t=this.wrapperNode.getBoundingClientRect();e="horizontal"===this.direction?t.left:t.top}const s=i.getBoundingClientRect();o=("horizontal"===this.direction?s.left:s.top)+this.scroll-e}o+=i,this.targetScroll=o,!this.smooth||e?this.setScroll(this.targetScroll):this.animate.to(this,{duration:s,easing:r,scroll:this.targetScroll})}}export{o as default};
//# sourceMappingURL=lenis.modern.mjs.map
